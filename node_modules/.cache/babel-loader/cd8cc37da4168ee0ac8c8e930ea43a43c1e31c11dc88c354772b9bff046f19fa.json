{"ast":null,"code":"import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n  send(method, params) {\n    const request = {\n      method: method,\n      params: params,\n      id: this._nextId++,\n      jsonrpc: \"2.0\"\n    };\n    if (this._pendingBatch == null) {\n      this._pendingBatch = [];\n    }\n    const inflightRequest = {\n      request,\n      resolve: null,\n      reject: null\n    };\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n    this._pendingBatch.push(inflightRequest);\n    if (!this._pendingBatchAggregator) {\n      // Schedule batch for next event loop + short duration\n      this._pendingBatchAggregator = setTimeout(() => {\n        // Get teh current batch and clear it, so new requests\n        // go into the next batch\n        const batch = this._pendingBatch;\n        this._pendingBatch = null;\n        this._pendingBatchAggregator = null;\n        // Get the request as an array of requests\n        const request = batch.map(inflight => inflight.request);\n        this.emit(\"debug\", {\n          action: \"requestBatch\",\n          request: deepCopy(request),\n          provider: this\n        });\n        return fetchJson(this.connection, JSON.stringify(request)).then(result => {\n          this.emit(\"debug\", {\n            action: \"response\",\n            request: request,\n            response: result,\n            provider: this\n          });\n          // For each result, feed it to the correct Promise, depending\n          // on whether it was a success or error\n          batch.forEach((inflightRequest, index) => {\n            const payload = result[index];\n            if (payload.error) {\n              const error = new Error(payload.error.message);\n              error.code = payload.error.code;\n              error.data = payload.error.data;\n              inflightRequest.reject(error);\n            } else {\n              inflightRequest.resolve(payload.result);\n            }\n          });\n        }, error => {\n          this.emit(\"debug\", {\n            action: \"response\",\n            error: error,\n            request: request,\n            provider: this\n          });\n          batch.forEach(inflightRequest => {\n            inflightRequest.reject(error);\n          });\n        });\n      }, 10);\n    }\n    return promise;\n  }\n}","map":{"version":3,"names":["deepCopy","fetchJson","JsonRpcProvider","JsonRpcBatchProvider","send","method","params","request","id","_nextId","jsonrpc","_pendingBatch","inflightRequest","resolve","reject","promise","Promise","push","_pendingBatchAggregator","setTimeout","batch","map","inflight","emit","action","provider","connection","JSON","stringify","then","result","response","forEach","index","payload","error","Error","message","code","data"],"sources":["D:\\repos\\TruePass\\node_modules\\@ethersproject\\providers\\src.ts\\json-rpc-batch-provider.ts"],"sourcesContent":["\r\nimport { deepCopy } from \"@ethersproject/properties\";\r\nimport { fetchJson } from \"@ethersproject/web\";\r\n\r\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\r\n\r\n// Experimental\r\n\r\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\r\n    _pendingBatchAggregator: NodeJS.Timer;\r\n    _pendingBatch: Array<{\r\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\r\n        resolve: (result: any) => void,\r\n        reject: (error: Error) => void\r\n    }>;\r\n\r\n    send(method: string, params: Array<any>): Promise<any> {\r\n        const request = {\r\n            method: method,\r\n            params: params,\r\n            id: (this._nextId++),\r\n            jsonrpc: \"2.0\"\r\n        };\r\n\r\n        if (this._pendingBatch == null) {\r\n            this._pendingBatch = [ ];\r\n        }\r\n\r\n        const inflightRequest: any = { request, resolve: null, reject: null };\r\n\r\n        const promise = new Promise((resolve, reject) => {\r\n            inflightRequest.resolve = resolve;\r\n            inflightRequest.reject = reject;\r\n        });\r\n\r\n        this._pendingBatch.push(inflightRequest);\r\n\r\n        if (!this._pendingBatchAggregator) {\r\n            // Schedule batch for next event loop + short duration\r\n            this._pendingBatchAggregator = setTimeout(() => {\r\n\r\n                // Get teh current batch and clear it, so new requests\r\n                // go into the next batch\r\n                const batch = this._pendingBatch;\r\n                this._pendingBatch = null;\r\n                this._pendingBatchAggregator = null;\r\n\r\n                // Get the request as an array of requests\r\n                const request = batch.map((inflight) => inflight.request);\r\n\r\n                this.emit(\"debug\", {\r\n                    action: \"requestBatch\",\r\n                    request: deepCopy(request),\r\n                    provider: this\r\n                });\r\n\r\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\r\n                    this.emit(\"debug\", {\r\n                        action: \"response\",\r\n                        request: request,\r\n                        response: result,\r\n                        provider: this\r\n                    });\r\n\r\n                    // For each result, feed it to the correct Promise, depending\r\n                    // on whether it was a success or error\r\n                    batch.forEach((inflightRequest, index) => {\r\n                        const payload = result[index];\r\n                        if (payload.error) {\r\n                            const error = new Error(payload.error.message);\r\n                            (<any>error).code = payload.error.code;\r\n                            (<any>error).data = payload.error.data;\r\n                            inflightRequest.reject(error);\r\n                        } else {\r\n                            inflightRequest.resolve(payload.result);\r\n                        }\r\n                    });\r\n\r\n                }, (error) => {\r\n                    this.emit(\"debug\", {\r\n                        action: \"response\",\r\n                        error: error,\r\n                        request: request,\r\n                        provider: this\r\n                    });\r\n\r\n                    batch.forEach((inflightRequest) => {\r\n                        inflightRequest.reject(error);\r\n                    });\r\n                });\r\n\r\n            }, 10);\r\n        }\r\n\r\n        return promise;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}